---
name: commit
description: Git差分を分析して適切な粒度でコミットを作成する。変更の「Why」を質問で引き出し、意味のあるコミットメッセージを生成する。コミット、git commit、変更をコミットしたい時に使う。
disable-model-invocation: true
---

## Step 1: 差分の分析
`git status` と `git diff` で変更内容を把握する。

問題や懸念がある場合（コンフリクト、意図しない変更など）は報告し、コミットしない。

## Step 2: コミットのグルーピング
以下の基準で変更をグループ分けする：
- 1コミット = 1つの論理的な変更
- 依存関係のある変更は同じコミットにまとめる

グループ分けの結果を表示する：
```
コミット 1: [対象ファイル一覧]
  概要: ～～～
コミット 2: [対象ファイル一覧]
  概要: ～～～
```

## Step 3: コミットごとに以下を繰り返す

### 3a: ステージング
適切な粒度で `git add` する。

### 3b: Whyの把握
ステージした差分とセッション履歴を分析し、変更の「Why（理由）」を理解する。

**セッション履歴から Why が推測できる場合は質問せず、そのまま Step 3c へ進む。**

推測できない場合のみ、必要な質問を**すべて一度に**提示する。
質問の数は変更の複雑さと利用可能なコンテキストに応じて変わる。

良い質問の例（差分に具体的な変更が見えるとき）：
- タイムアウト値の変更 →「タイムアウトを 3秒 → 5秒 に増やした理由は？」
- nil チェックの追加 →「この nil チェックはどんなエッジケースに対応するもの？」
- リファクタリング →「大きなクリーンアップの一環？それとも特定の問題があった？」
- テスト分割 →「テストを複数に分けた理由は？」

悪い質問の例（避けること）：
- 「ファイルを更新しましたか？」（差分から明らか）
- 「X の新しい値は？」（差分に書いてある）
- 「この変更は何ですか？」（抽象的すぎる。Why に焦点を当てる）

### 3c: コミットメッセージの生成とコミット
回答（またはセッション履歴から推測した理由）をもとにコミットメッセージを生成し、コミットする。

### 3d: 次のコミットへ
未ステージの変更が残っていれば Step 3a に戻る。
すべて完了したら終了。

**このコマンド実行後は通常モードに戻る。ユーザーが明示的に `/commit` を再実行するまで自動コミットしない。**
